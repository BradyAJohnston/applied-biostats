---
title: "Simulation -- modeling experiments"
author: "Jeffrey A. Walker"
date: "2/23/2021"
output: html_document
---
## Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(data.table)
library(mvtnorm)
library(magrittr)
library(doBy)
library(dplyr)

library(nlme)
library(lmerTest)
library(emmeans)
library(afex)
library(car)

library(ggplot2)
library(ggpubr)
library(knitr)
library(kableExtra)
library(printy)

sim_data <- "sim_data"

```

Notes
1. previous simulations didn't model true type I with zero effects but zero population effect. There were individual treatment effects.

2. so a better model is how well it performs when variance among individuals >> treatment effect. But, how to think about this in type I setting? Coverage of CIs. Type I is kinda like too narrow intervals.

## Simulation functions

```{r safe}
safelme <- purrr::safely(lme, otherwise = NA)

quietlmer <- purrr::quietly(lmer)

```


```{r lmer_check}
lmer_check <- function(fit){
  return(fit@optinfo$conv$lme4$messages)
}
```


```{r contrast_stats}
contrast_stats <- function(fit, ...){
  fit_pairs <- contrast(emmeans(fit, ...),
                        method = "revpairwise",
                        adjust = "none") %>%
    summary(infer = TRUE)
  b_hat <- fit_pairs[1, "estimate"]
  lower <- fit_pairs[1, "lower.CL"]
  upper <- fit_pairs[1, "upper.CL"]
  p_value <- fit_pairs[1, "p.value"]
  return(list(b_hat = b_hat,
              lower = lower,
              upper = upper,
              p_value = p_value))
}
```

```{r}
penalized_power <- function(pow,
                            t1,
                            alpha = 0.05){
  beta <- 1 - pow
  gamma <- (1 - beta)/(sqrt(1 + abs(1 - t1/alpha)))
  return(gamma)
}
```

## Simulator
```{r}
get_n_vec_wide <- function(n, n_groups){
    n_vec <- rep(n, n_groups)
    inc <- floor(n_groups/4)
    n1 <- floor(3/5*n)
    j <- 1
    n_vec[j:(j+inc-1)] <- n1
    n2 <- floor(4/5*n)
    j <- j + inc
    n_vec[j:(j+inc-1)] <- n2
    n4 <- ceiling(6/5*n)
    j <- j + inc
    n_vec[j:(j+inc-1)] <- n4
    n5 <- ceiling(7/5*n)
    j <- j + inc
    n_vec[j:(j+inc-1)] <- n5
    return(n_vec)
}

get_n_vec_narrow <- function(n, n_groups){
    n_vec <- rep(n, n_groups)
    inc <- floor(n_groups/4)
    n1 <- n-2
    j <- 1
    n_vec[j:(j+inc-1)] <- n1
    n2 <- n-1
    j <- j + inc
    n_vec[j:(j+inc-1)] <- n2
    n4 <- n+1
    j <- j + inc
    n_vec[j:(j+inc-1)] <- n4
    n5 <- n+2
    j <- j + inc
    n_vec[j:(j+inc-1)] <- n5
    n_vec[c(1, n_groups)] <- n
    return(n_vec)
}

get_n_rand <- function(n,
                       n_groups,
                       n_with_missing,
                       n_missing){
    n_vec <- rep(n, n_groups)
    inc <- sample(seq_along(n_vec), n_with_missing)
    sample_this <- c(seq_len(n_missing),
                     seq_len(n_missing)*-1)
    n_vec[inc] <- n + sample(sample_this,
                             n_with_missing,
                             replace = TRUE)
    return(n_vec)
}
```


```{r}
simulator <- function(
  seed_i = 1,
  n_sim = 2000,
  n = 10,
  n_id = 5,
  n_treat = c(2,2),
  beta = c(10,1,1,1),
  sigma = c(1,1,1,1), # one for each id
  gamma = c(1,1,1,1), # random intercept and slopes for non-ref
  rho = rep(0.6, 12), # r between random intercept and slopes
  equal_n = TRUE,
  n_with_missing = 1, # number of groups with missing
  n_missing = 1 # max number of missing in agroup
){
  
  if(length(n_treat) == 2){
    factorial <- TRUE
  }else{
    factorial <- FALSE
  }
  # returns N by n_sim matrix of fake data. Each sim is in its own column. The first two columns are treatment and id 
  n_treat_combi <- prod(n_treat)
  if(length(sigma) == 1){
    sigma <- rep(sigma, n_treat_combi)
  }
  N <- n*n_treat_combi*n_id
  
  if(factorial == TRUE){
    # for factorial
    genotype_levels <- c("WT", "KO")
    treatment_levels <- c("Tr1", "Tr2")
    id_levels <- paste0("id_", 1:n_id)
    g.by.t_levels <- do.call(paste,
                             expand.grid(genotype_levels,
                                         treatment_levels))
    
    tc.by.id_levels <- do.call(paste,
                               expand.grid(genotype_levels,
                                           treatment_levels,
                                           id_levels))
  }else{
    # for single-factor
    treatment_levels <- c("CN", "Tr1", "Tr2", "Tr3")[1:n_treat]
    id_levels <- paste0("id_", 1:n_id)
    t.by.id_levels <- do.call(paste,
                              expand.grid(treatment_levels,
                                          id_levels))
  }

  n_groups <- n_treat_combi*n_id
  if(equal_n == FALSE){
    n_vec <- get_n_vec_narrow(n, n_groups)
    # n_vec <- get_n_rand(n,
    #                     n_groups,
    #                     n_with_missing,
    #                     n_missing)
    
  }else{
    n_vec <- rep(n, n_treat_combi*n_id)
  }
  
  fake_data_all <- data.table(NULL)

  # random component
  # random variance matrix
  # gamma[1] is std of random intercept u_0
  # gamma[2] is std of random slope for first non-reference
  #     treatment level
  # gamma[3] is std of random slope for second non-reference
  #     treatment level
  # gamma[4] is std of random slope for interaction
  L <- diag(gamma)
  Psi_R <- diag(length(gamma))
  Psi_R[lower.tri(Psi_R, diag = FALSE)] <- rho
  Psi_R <- t(Psi_R)
  Psi_R[lower.tri(Psi_R, diag = FALSE)] <- rho
  Psi <- L%*%Psi_R%*%L

  fd_mat <- matrix(as.numeric(NA), nrow = N, ncol = n_sim)
  colnames(fd_mat) <- paste0("sim_", 1:n_sim)
  group_mat <- matrix(NA, nrow = N, ncol = n_sim) %>%
    as.data.frame
  colnames(group_mat) <- paste0("sim_", 1:n_sim)

  for(sim_i in 1:n_sim){
    seed_i <- seed_i + 1
    sim_seed <- seed_i
    set.seed(sim_seed)
    
    n_vec_i <- sample(n_vec)
    
    set.seed(seed_i)
    
    if(factorial == TRUE){
      group_mat[, sim_i] <- rep(tc.by.id_levels, n_vec_i)
      fake_data_all[, tc.by.id := rep(tc.by.id_levels, n_vec_i)]
      fake_data_all[, c("genotype","treatment", "id") :=
                      tstrsplit(tc.by.id,
                                " ",
                                fixed = TRUE)]
      
      # order factor levels
      fake_data_all[, treatment := factor(treatment,
                                          levels = treatment_levels)]
      fake_data_all[, genotype := factor(genotype,
                                         levels = genotype_levels)]
      fake_data_all[, id := factor(id,
                                   levels = id_levels)]
      fake_data_all[, sigma_group := factor(paste(genotype, treatment),
                                       levels = g.by.t_levels)]
      
      # fixed design matrix
      X <- model.matrix(~ genotype * treatment,
                        data = fake_data_all)

      # random design matrix
      # random intercepts and slopes
      # 4 g0 + 4 g1 + 4 g2 + 4 g3
      Z <- model.matrix(~ 0 + id + id:genotype + id:treatment +
                          id:genotype:treatment,
                        data = fake_data_all)
    }else{
      group_mat[, sim_i] <- rep(t.by.id_levels, n_vec_i)
      fake_data_all[, t.by.id := rep(t.by.id_levels, n_vec_i)]
      fake_data_all[, c("treatment", "id") :=
                      tstrsplit(t.by.id,
                                " ",
                                fixed = TRUE)]
      
      # order factor levels
      fake_data_all[, treatment := factor(treatment,
                                          levels = treatment_levels)]
      fake_data_all[, id := factor(id,
                                   levels = id_levels)]
      fake_data_all[, sigma_group := treatment]
      
      # fixed design matrix
      X <- model.matrix(~ treatment,
                        data = fake_data_all)

      # random design matrix
      # 4 g0 + 4 g1 + 4 g2 + 4 g3
      Z <- model.matrix(~ 0 + id + id:treatment,
                        data = fake_data_all)

      # Z <- model.matrix(~ 0 + id + id:treatment,
      #                   data = fake_data_all,
      #                   contrasts = list(id = contr.sum,
      #                                    treatment = contr.sum))
    }
    
    # fixed component
    y_fixed <- (X %*% beta)[,1]
    
    # cols are gamma0, gamma1, ...
    # rows are id
    u_mat <- rmvnorm(n_id,
                     sigma = Psi)
#    u_mat_s <- scale(u_mat, center=TRUE, scale=FALSE)
    
    # flattened to a vector, order is
    # g0 for id1..k, then
    # g1 for id1..k, then...
    u <- c(u_mat)
    
    y_rand <- (Z %*% u)[,1]
#    y_rand <- y_rand - mean(y_rand)

    # check!
    # colnames(Z) <- 1:ncol(Z)
    # head(cbind(fake_data_all[,1:3], Z))
    # u_mat
    # u

 #   double check!
    # fake_y <- rnorm(nrow(fake_data_all))
    # lForm <- lFormula(fake_y ~ genotype*treatment + (genotype*treatment | id),
    #                   fake_data_all)    # lme4's function to process a model formula
    # Z2 <- t(as.matrix(lForm$reTrms$Zt))
    # u1 <- t(c(t(u_mat)))[1,]
    # y_rand2 <- (Z2 %*% u1)[,1]
    
    sigma_vec <- sigma[as.integer(fake_data_all[, sigma_group])]
    e <- rnorm(N, sd = sigma_vec)
    
    # more checks
    # check_data <- cbind(fake_data_all,y_rand, e)
    # check_data[, .(sd_e = sd(e),
    #                sd_y_rand = sd(y_rand)),
    #            by = .(genotype, treatment)]
    
    fd_mat[, sim_i] <- y_fixed + y_rand + e
  }
  fake_data_all <- cbind(fake_data_all,
                         fd_mat)
  return(list(fd_mat = fd_mat,
              group_mat = group_mat))
}
```

```{r}
get_flat_groups <- function(fake_data){
  fake_data[, c("treatment", "id") :=
              tstrsplit(group,
                        " ",
                        fixed = TRUE)]
  
  # order factor levels
  fake_data[, treatment := factor(treatment)]
  fake_data[, id := factor(id)]
  return(fake_data)
}

get_factorial_groups <- function(fake_data){

}
```

## Simulate this

###  Factorial vs flat -- sensitivity of lmer
```{r}
simulate_this_sensitivity <- function(
  seed_i = 1,
  n_sim = 2000,
  n = 1,
  n_id = 5,
  n_treat = c(2,2),
  beta = c(10,1,1,),
  sigma = c(1,1,1,),
  gamma = c(1,1,1,),
  rho = rep(0.6, 3), # r between random intercept and slope
  equal_n = TRUE
){
  
  # get fake data for all n_sim runs
    all_data <- simulator(
      seed_i = seed_i,
      n_sim = n_sim,
      n = n,
      n_id = n_id,
      n_treat = n_treat,
      beta = beta,
      sigma = sigma,
      gamma = gamma,
      rho = rho,
      equal_n = equal_n
    )    

  methods <- c("factorial",
               "flat",
               "factorial_intercept",
               "flat_intercept")
  
  n_methods <- length(methods)
  
  p_mat <- matrix(as.numeric(NA), nrow = n_sim, ncol = n_methods)
  error_mat <- matrix(as.numeric(NA), nrow = n_sim, ncol = n_methods)
  lower_mat <- matrix(as.numeric(NA), nrow = n_sim, ncol = n_methods)
  upper_mat <- matrix(as.numeric(NA), nrow = n_sim, ncol = n_methods)
  colnames(p_mat) <- methods
  colnames(error_mat) <- methods
  colnames(lower_mat) <- methods
  colnames(upper_mat) <- methods
  
  start_y <- which(colnames(all_data) == "sim_1")
  end_y <- ncol(all_data)
  fake_data <- all_data[, 1:(start_y-1)]
  fake_matrix <- all_data[, start_y:end_y] %>%
    as.matrix()
  for(sim_i in 1:n_sim){
    fake_data[, y := fake_matrix[, sim_i]]
    
    # slope and intercept models
    m1 <- lmer(y ~ genotype * treatment + (genotype * treatment | id),
               data = fake_data)
    m2 <- lmer(y ~ group + (group | id),
               data = fake_data)

    m3 <- lmer(y ~ genotype * treatment +
                 (1 | id) +
                 (1 | id:genotype) + 
                 (1 | id:treatment) +
                 (1 | id:genotype:treatment),
               data = fake_data)
    
    m4 <- lmer(y ~ group + (1 | id) +
                 (1 | id:group),
               data = fake_data)
   
    res1 <- contrast_stats(m1, specs = c("genotype", "treatment"))
    res2 <- contrast_stats(m2, specs = c("group"))
    res3 <- contrast_stats(m1, specs = c("genotype", "treatment"))
    res4 <- contrast_stats(m2, specs = c("group"))
    
    warning_list <- c(
      ifelse(is.null(lmer_check(m1)), res1$p_value, NA),
      ifelse(is.null(lmer_check(m2)), res2$p_value, NA),
      ifelse(is.null(lmer_check(m3)), res2$p_value, NA),
      ifelse(is.null(lmer_check(m4)), res2$p_value, NA)
    )

    res_mat <- rbind(unlist(res1),
                     unlist(res2),
                     unlist(res3),
                     unlist(res4))
    
    p_mat[sim_i, ] <- res_mat[, "p_value"]
    lower_mat[sim_i, ] <- res_mat[, "lower"]
    upper_mat[sim_i, ] <- res_mat[, "upper"]

    error_mat[sim_i, "factorial"] <- warning_list[1]
    error_mat[sim_i, "flat"] <- warning_list[2]
    error_mat[sim_i, "factorial_intercept"] <- warning_list[3]
    error_mat[sim_i, "flat_intercept"] <- warning_list[4]
   }

  return(list(p_mat = p_mat,
              error_mat = error_mat,
              lower_mat = lower_mat,
              upper_mat = upper_mat))
}
```

###  Single Factor RCB without subsampling
```{r}
simulate_this_RCB_no_subsampling <- function(
  seed_i = 1,
  n_sim = 2000,
  n = 1,
  n_id = 5,
  n_treat = 3,
  beta = c(10,1,1,),
  sigma = c(1,1,1,),
  gamma = c(1,1,1,),
  rho = rep(0.6, 3), # r between random intercept and slope
  equal_n = TRUE,
  n_with_missing = 1,
  n_missing = 1,
  do_lme = FALSE
){
  
  # get fake data for all n_sim runs
    all_data <- simulator(
      seed_i = seed_i,
      n_sim = n_sim,
      n = n,
      n_id = n_id,
      n_treat = n_treat,
      beta = beta,
      sigma = sigma,
      gamma = gamma,
      rho = rho,
      equal_n = equal_n,
      n_with_missing = n_with_missing,
      n_missing = n_missing
    )
  fake_group <- all_data$group_mat
  fake_matrix <- all_data$fd_mat

  methods <- c("lmm_intercept",
               "lme_cor",
               "lme_weight",
               "lme_both",
               "lmm_aic_multi",
               "lmm_aic_uni",
               "aov4_multi",
               "aov4_uni")
  
  n_methods <- length(methods)
  
  b_mat <- matrix(as.numeric(NA), nrow = n_sim, ncol = n_methods)
  p_mat <- matrix(as.numeric(NA), nrow = n_sim, ncol = n_methods)
  error_mat <- matrix(as.numeric(NA), nrow = n_sim, ncol = n_methods)
  lower_mat <- matrix(as.numeric(NA), nrow = n_sim, ncol = n_methods)
  upper_mat <- matrix(as.numeric(NA), nrow = n_sim, ncol = n_methods)
  colnames(b_mat) <- methods
  colnames(p_mat) <- methods
  colnames(error_mat) <- methods
  colnames(lower_mat) <- methods
  colnames(upper_mat) <- methods
  
  res1 <- list(NULL)
  res2 <- list(NULL)
  res3 <- list(NULL)
  res4 <- list(NULL)
  
  for(sim_i in 1:n_sim){
    fake_data[, group := fake_group[, sim_i]]
    fake_data[, y := fake_matrix[, sim_i]]
    fake_data <- get_flat_groups(fake_data)

    # ANOVA models
    m5 <- aov_4(y ~ treatment +
                  (treatment | id),
                data = fake_data)
    res7 <- contrast_stats(m5,
                            specs = c("treatment"),
                            model = "multivariate")
    res8 <- contrast_stats(m5,
                            specs = c("treatment"),
                            model = "univariate")

    if(do_lme == TRUE){
      m1 <- lmer(y ~ treatment + (1 | id),
                 data = fake_data)
      m2 <- safelme(y ~ treatment,
                    random = ~1 | id,
                    correlation = corSymm(form = ~ 1 | id),
                    data = fake_data)$result
      m3 <- safelme(y ~ treatment,
                    random = ~1 | id,
                    weight = varIdent(form = ~ 1 | treatment),
                    data = fake_data)$result
      m4 <- safelme(y ~ treatment,
                    random = ~1 | id,
                    correlation = corSymm(form = ~ 1 | id),
                    weight = varIdent(form = ~ 1 | treatment),
                    data = fake_data)$result
      
      aic_lme <- c(NA,NA,NA,NA)
      if(is.null(lmer_check(m1))){
        res1 <- contrast_stats(m1, specs = c("treatment"))
        aic_lme[1] <- AIC(m1)
      }else{
        res1$b_hat <- NA
        res1$lower <- NA
        res1$upper <- NA
        res1$p_value <- NA
      }
      if(!is.na(m2[1])){
        res2 <- contrast_stats(m2,
                               specs = c("treatment"),
                               data = fake_data)
        aic_lme[2] <- AIC(m2)
      }else{
        res2$b_hat <- NA
        res2$lower <- NA
        res2$upper <- NA
        res2$p_value <- NA
      }
      if(!is.na(m3[1])){
        res3 <- contrast_stats(m3,
                               specs = c("treatment"),
                               data = fake_data)
        aic_lme[3] <- AIC(m3)
      }else{
        res3$b_hat <- NA
        res3$lower <- NA
        res3$upper <- NA
        res3$p_value <- NA
      }
      if(!is.na(m4[1])){
        res4 <- contrast_stats(m4,
                               specs = c("treatment"),
                               data = fake_data)
        aic_lme[4] <- AIC(m4)
      }else{
        res4$b_hat <- NA
        res4$lower <- NA
        res4$upper <- NA
        res4$p_value <- NA
      }

      safe_min_model <- which.min(aic_lme)
      if(length(safe_min_model) > 0){
        if(safe_min_model == 1){res5 <- res1}
        if(safe_min_model == 2){res5 <- res2}
        if(safe_min_model == 3){res5 <- res3}
        if(safe_min_model == 4){res5 <- res4}
        res6 <- res5
      }else{
        res5 <- res7 # multi
        res6 <- res8 # uni
      }      
    } # do lme
    


    res_mat <- rbind(unlist(res1),
                     unlist(res2),
                     unlist(res3),
                     unlist(res4),
                     unlist(res5),
                     unlist(res6),
                     unlist(res7),
                     unlist(res8))
    
    b_mat[sim_i, ] <- res_mat[, "b_hat"]
    p_mat[sim_i, ] <- res_mat[, "p_value"]
    lower_mat[sim_i, ] <- res_mat[, "lower"]
    upper_mat[sim_i, ] <- res_mat[, "upper"]
    error_mat[sim_i, ] <- res_mat[, "p_value"]
  }
  return(list(b_mat = b_mat,
              p_mat = p_mat,
              error_mat = error_mat,
              lower_mat = lower_mat,
              upper_mat = upper_mat))
}
```


###  Single Factor RCB with subsampling
```{r}
simulate_this_RCB_subsampling <- function(
  seed_i = 1,
  n_sim = 2000,
  n = 1,
  n_id = 5,
  n_treat = 3,
  beta = c(10,1,1,),
  sigma = c(1,1,1,),
  gamma = c(1,1,1,),
  rho = rep(0.6, 3), # r between random intercept and slope
  equal_n = TRUE,
  n_with_missing = 1,
  n_missing = 1,
  do_lme = FALSE
){
  
  # get fake data for all n_sim runs
    all_data <- simulator(
      seed_i = seed_i,
      n_sim = n_sim,
      n = n,
      n_id = n_id,
      n_treat = n_treat,
      beta = beta,
      sigma = sigma,
      gamma = gamma,
      rho = rho,
      equal_n = equal_n,
      n_with_missing = n_with_missing,
      n_missing = n_missing
    )
  fake_group <- all_data$group_mat
  fake_matrix <- all_data$fd_mat

  methods <- c("lm",
               "lmm_slope",
               "lmm_intercept",
               "lmm_intercept_ixn",
               "lmm_aic_multi",
               "lmm_aic_uni",
               "aov4_multi",
               "aov4_uni",
               "lmm_cor_min_aic",
               "lmm_all_min_aic")
  
  n_methods <- length(methods)
  
  b_mat <- matrix(as.numeric(NA), nrow = n_sim, ncol = n_methods)
  p_mat <- matrix(as.numeric(NA), nrow = n_sim, ncol = n_methods)
  error_mat <- matrix(as.numeric(NA), nrow = n_sim, ncol = n_methods)
  lower_mat <- matrix(as.numeric(NA), nrow = n_sim, ncol = n_methods)
  upper_mat <- matrix(as.numeric(NA), nrow = n_sim, ncol = n_methods)
  colnames(b_mat) <- methods
  colnames(p_mat) <- methods
  colnames(error_mat) <- methods
  colnames(lower_mat) <- methods
  colnames(upper_mat) <- methods
  
  # lme methods may not be computed
  res8 <- list(NULL)
  res8$lower <- NA
  res8$upper <- NA
  res8$p_value <- NA
  res9 <- list(NULL)
  res9$lower <- NA
  res9$upper <- NA
  res9$p_value <- NA
  
  for(sim_i in 1:n_sim){
    fake_data[, group := fake_group[, sim_i]]
    fake_data[, y := fake_matrix[, sim_i]]
    fake_data <- get_flat_groups(fake_data)

    m0 <- lm(y ~ treatment,
               data = fake_data)
    
    # slope and intercept models
    m1 <- lmer(y ~ treatment + (treatment | id),
               data = fake_data)
    m2 <- lmer(y ~ treatment + (1 | id),
               data = fake_data)
    m3 <- lmer(y ~ treatment + (1 | id) + (1 | id:treatment),
               data = fake_data)
    
    # anova models
    m4 <- aov_4(y ~ treatment +
                  (treatment | id),
                data = fake_data)
    
    res0 <- contrast_stats(m0, specs = c("treatment"))
    res1 <- contrast_stats(m1, specs = c("treatment"))
    res2 <- contrast_stats(m2, specs = c("treatment"))
    res3 <- contrast_stats(m3, specs = c("treatment"))
    
    # ANOVA models
    # need before res4 and 5 because res5 = res7 if
    # all lmm models fail
    res6 <- contrast_stats(m4,
                            specs = c("treatment"),
                            model = "multivariate")
    res7 <- contrast_stats(m4,
                            specs = c("treatment"),
                            model = "univariate")

    # best AIC models (res4, res5)
    aic_list <- AIC(m1, m2, m3)[,"AIC"]
    warning_list <- c(
      ifelse(is.null(lmer_check(m1)), res1$p_value, NA),
      ifelse(is.null(lmer_check(m2)), res2$p_value, NA),
      ifelse(is.null(lmer_check(m3)), res3$p_value, NA)
    )
    safe_aic_list <- ifelse(is.na(warning_list), NA, aic_list)
    safe_min_model <- which.min(safe_aic_list)
    if(length(safe_min_model) > 0){
      if(safe_min_model == 1){res5 <- res1}
      if(safe_min_model == 2){res5 <- res2}
      if(safe_min_model == 3){res5 <- res3}
      res4 <- res5
    }else{
      res4 <- res6 # multi
      res5 <- res7 # uni
    }

    # correlated error models
    if(do_lme == TRUE){
      aic_lme <- c(NA,NA,NA)
      m6 <- safelme(y ~ treatment,
                    random = ~1 | id,
                    correlation = corSymm(form = ~ 1 | id),
                    data = fake_data)$result
      if(!is.na(m6[1])){aic_lme[1] <- AIC(m6)}
      m7 <- safelme(y ~ treatment,
                    random = ~1 | id,
                    weight = varIdent(form = ~ 1 | treatment),
                    data = fake_data)$result
      if(!is.na(m7[1])){aic_lme[2] <- AIC(m7)}
      m8 <- safelme(y ~ treatment,
                    random = ~1 | id,
                    correlation = corSymm(form = ~ 1 | id),
                    weight = varIdent(form = ~ 1 | treatment),
                    data = fake_data)$result
      if(!is.na(m8[1])){aic_lme[3] <- AIC(m8)}
      
      # res8 is min AIC of lme models
      lme_min_model <- which.min(aic_lme)
      if(length(lme_min_model) > 0){
        if(lme_min_model == 1){lme_mod <- m6}
        if(lme_min_model == 2){lme_mod <- m7}
        if(lme_min_model == 3){lme_mod <- m8}
        res8 <- contrast_stats(lme_mod,
                               specs = c("treatment"),
                               data = fake_data)
      }else{
        res8$b_hat <- NA
        res8$lower <- NA
        res8$upper <- NA
        res8$p_value <- NA
      }
      
      # res9 is min AIC of all lmm models
      if(length(lme_min_model) > 0 &
         length(safe_min_model) > 0){
        if(min(safe_aic_list, na.rm=TRUE) < min(aic_lme, na.rm=TRUE)){
          res9 <- res5 # lmer safe AIC model
        }else{
          res9 <- res8 # lme model
        }
      }
      if(length(lme_min_model) > 0 &
         length(safe_min_model) == 0){
          res9 <- res8 # lme model
      }
      if(length(lme_min_model) == 0 &
         length(safe_min_model) > 0){
          res9 <- res5 # lmer safe AIC model
      }
      if(length(lme_min_model) == 0 &
         length(safe_min_model) == 0){
        res9$b_hat <- NA
        res9$lower <- NA
        res9$upper <- NA
        res9$p_value <- NA
      }
    }

    res_mat <- rbind(unlist(res0),
                     unlist(res1),
                     unlist(res2),
                     unlist(res3),
                     unlist(res4),
                     unlist(res5),
                     unlist(res6),
                     unlist(res7),
                     unlist(res8),
                     unlist(res9))
    
    b_mat[sim_i, ] <- res_mat[, "b_hat"]
    p_mat[sim_i, ] <- res_mat[, "p_value"]
    lower_mat[sim_i, ] <- res_mat[, "lower"]
    upper_mat[sim_i, ] <- res_mat[, "upper"]

    error_mat[sim_i, "lm"] <- res0$p_value
    error_mat[sim_i, "lmm_slope"] <- warning_list[1]
    error_mat[sim_i, "lmm_intercept"] <- warning_list[2]
    error_mat[sim_i, "lmm_intercept_ixn"] <- warning_list[3]
    error_mat[sim_i, "lmm_aic_multi"] <- res4$p_value
    error_mat[sim_i, "lmm_aic_uni"] <- res5$p_value
    error_mat[sim_i, "aov4_multi"] <- res6$p_value
    error_mat[sim_i, "aov4_uni"] <- res7$p_value
    error_mat[sim_i, "lmm_cor_min_aic"] <- res8$p_value
    error_mat[sim_i, "lmm_all_min_aic"] <- res9$p_value
  }
  return(list(b_mat = b_mat,
              p_mat = p_mat,
              error_mat = error_mat,
              lower_mat = lower_mat,
              upper_mat = upper_mat))
}
```


## Exploration
### Equivalence of linear mixed model and mixed ANOVA (repeated measures ANOVA with subsampling)

```{r eval=FALSE}
fake_data <- simulator(
  seed_i = 1,
  n_sim = 1,
  n = 10,
  n_id = 10,
  n_treat = c(2,2),
  beta = c(10,1,1,1),
  sigma = c(1,1,1,1), # one for each id
  gamma = c(1,1,1,1), # random intercept and slopes for non-ref
  rho = rep(0.6, 4*3/2), # r between random intercept and slopes
  equal_n = TRUE
)

m1 <- lmer(sim_1 ~ genotype * treatment +
             (1 | id) +
             (1 | id:genotype) +
             (1 | id:treatment) +
             (1 | id:genotype:treatment),
           data = fake_data)
m2 <- aov_4(sim_1 ~ genotype * treatment +
             (genotype * treatment | id),
           data = fake_data)

m1_aov <- anova(m1)
m2_aov <- anova(m2)
```

Contrast tables

```{r echo=FALSE, eval=FALSE}
pairs_a <- emmeans(m1, specs = c("genotype", "treatment")) %>%
  contrast(method = "revpairwise",
           simple = "each",
           combine = TRUE,
           adjust = "none"
  )%>%
  summary(infer = TRUE)
pairs_b <- emmeans(m2,
                   specs = c("genotype", "treatment"),
                   model = "univariate") %>%
  contrast(method = "revpairwise",
           simple = "each",
           combine = TRUE,
           adjust = "none"
  )%>%
  summary(infer = TRUE)
pairs_c <- emmeans(m2,
                   specs = c("genotype", "treatment"),
                   model = "multivariate") %>%
  contrast(method = "revpairwise",
           simple = "each",
           combine = TRUE,
           adjust = "none"
  )%>%
  summary(infer = TRUE)

pairs_dt <- rbind(pairs_a, pairs_b, pairs_c)

pairs_dt %>%
  kable(digits = c(4), caption = "ANOVA tables from linear mixed model and two-way mixed ANOVA") %>%
  kable_styling() %>%
  pack_rows("m1 (lmm)", 1, 4) %>%
  pack_rows("m2 uni (two-way mixed ANOVA)", 5, 8) %>%
  pack_rows("m2 multi (two-way mixed ANOVA)", 9, 12)
```

ANOVA tables

```{r echo=FALSE, eval=FALSE}
m1_aov <- anova(m1)[, c(3,4,2,5,6)]
m2_aov <- anova(m2, correction = "none")[, c(1,2,3,4,6)]
colnames(m1_aov) <- colnames(m2_aov)

pairs_dt <- rbind(m1_aov, m2_aov)

pairs_dt %>%
  kable(digits = c(3,3,3,3,3), caption = "ANOVA tables from linear mixed model and two-way mixed ANOVA") %>%
  kable_styling() %>%
  pack_rows("m1 (lmm)", 1, 3) %>%
  pack_rows("m2 (two-way mixed ANOVA)", 4, 6)
```

### Factorial v flat sensitivity

```{r, message=FALSE, warning=FALSE, eval=FALSE}
save_it <- TRUE
fake_data <- data.table(NULL)
do_lme <- FALSE

n_sim <- 50
n <- 10
n_list <- c(5, 10, 20)
n_id <- 10
n_id_list <- c(5, 10, 20)
n_treat <- c(2,2)
N <- n*n_treat*n_id
beta_0 <- 10
beta_1_list <- c(0.8)
sigma <- 1
gamma_0_list = c(1) # intercept 
gamma_1_list = c(1) # slope
gamma_2_list = c(1) # slope
rho_list <- c("0", "+") # correlation between random intercept and slope
rho_list <- c("+") # correlation between random intercept and slope
equal_n_list <- c(TRUE) # equal_n_list
rho_vec <- rep(0.7, 6)

parameter_mat <- expand.grid(n = n_list,
                             n_id = n_id_list,
                             beta_1 = beta_1_list,
                             gamma_0 = gamma_0_list,
                             gamma_1 = gamma_1_list,
                             gamma_2 = gamma_2_list,
                             rho = rho_list,
                             equal_n = equal_n_list
                             ) %>%
  data.table
n_param <- nrow(parameter_mat)

big_table <- data.table(NULL)
t1_id <- 0
for(world in 1:nrow(parameter_mat)){
  if(parameter_mat[world, beta_1 == 0]){t1_id <- t1_id + 1}
  seed_i <- 1
  n <- parameter_mat[world, n]
  n_id <- parameter_mat[world, n_id]
  beta_1 <- parameter_mat[world, beta_1]
  beta_2 <- beta_1
  beta_3 <- beta_1
  gamma_0 <- parameter_mat[world, gamma_0]
  gamma_1 <- parameter_mat[world, gamma_1]
  gamma_2 <- parameter_mat[world, gamma_2]
  gamma_2 <- gamma_1
  gamma_3 <- gamma_1
  if(parameter_mat[world, rho] == "0"){
    rho <- rep(0, 6) 
  }
  if(parameter_mat[world, rho] == "+"){
    rho <- rho_vec 
  }
  equal_n_sim <- parameter_mat[world, equal_n]
  
  sim1 <- simulate_this_sensitivity(
    seed_i = seed_i,
    n_sim = n_sim,
    n = n,
    n_id = n_id,
    n_treat = n_treat,
    beta = c(beta_0, beta_1, beta_2, beta_3),
    sigma = sigma,
    gamma = c(gamma_0, gamma_1, gamma_2, gamma_3),
    rho = rho,
    equal_n = equal_n_sim
  )

  
  lower <- sim1$lower_mat
  upper <- sim1$upper_mat
  prob <- sim1$p_mat # remove last 4
  error <- sim1$error_mat

  stat_table <- rbind(data.table(stat = "lower", lower),
                      data.table(stat = "upper", upper),
                      data.table(stat = "prob", prob),
                      data.table(stat = "error", error))
  
  big_table <- rbind(big_table,
                     data.table(
                       sim_id = world,
                       t1_id = t1_id,
                       n = n,
                       n_id = n_id,
                       beta_1 = beta_1,
                       gamma_0 = gamma_0,
                       gamma_1 = gamma_1,
                       gamma_2 = gamma_2,
                       gamma_3 = gamma_3,
                       rho = parameter_mat[world, rho],
                       equal_n = equal_n_sim,
                       stat_table
                     ))
}

if(save_it == TRUE){
  outpath <- here::here("sim_data", "multi_experiments_sensitivity.Rds")
  saveRDS(big_table, outpath)
}
```

```{r eval=FALSE}
error <- big_table[stat == "error",]
ycols <- c("n", "n_id", "factorial", "flat", "factorial_intercept", "flat_intercept")
error[, .SD, .SDcols = ycols]
ycols <- c("factorial", "flat", "factorial_intercept", "flat_intercept")
error[, .(factorial = mean(!is.na(factorial))*100,
          flat = mean(!is.na(flat))*100,
          fac_int = mean(!is.na("factorial-intercept"))*100,
          flat_int = mean(!is.na("flat-intercept"))*100), by = .(n, n_id)]
```

### Single factor RCB without subsamples

```{r Single factor RCB without subsamples, message=FALSE, warning=FALSE, eval=FALSE}
save_it <- FALSE
read_it <- FALSE

fake_data <- data.table(NULL)
do_lme <- TRUE

n_sim <- 1000
n <- 1
n_id <- 10
n_id_list <- c(8)
n_treat <- 4
N <- n*n_treat*n_id
p_cor <- n_treat*(n_treat-1)/2 # number of correlations in Psi

beta_0 <- 10
beta_1_list <- c(0.2, 0.4)
sigma <- 1
# 
sigma_mat <- matrix(c(c(1, 1, 1, 1),
                      c(1, 1, 0.5, 0.5),
                      c(0.5, 1, 1, 0.5),
                      c(0.2, 1, 1, 0.5)), ncol = 4)
sigma_list <- c("sigma1", "sigma2", "sigma3", "sigma4")[1:ncol(sigma_mat)]
colnames(sigma_mat) <- sigma_list

gamma_0_list = c(1) # intercept 
gamma_1_list = c(0.2, 1) # slope
rho_list <- c("0", "+") # correlation between random intercept and slope
rho_list <- c("+") # correlation between random intercept and slope
rho_vec <- c(.8, .7, .6, .8, .7, .6)
equal_n_list <- c(TRUE) # equal_n_list
n_with_missing <- 1
n_missing <- 1

parameter_mat <- expand.grid(beta_1 = beta_1_list,
                             gamma_0 = gamma_0_list,
                             gamma_1 = gamma_1_list,
                             sigma_j = sigma_list,
                             rho = rho_list,
                             equal_n = equal_n_list,
                             n_id = n_id_list
                             ) %>%
  data.table

big_table <- data.table(NULL)
t1_id <- 0
for(world in 1:nrow(parameter_mat)){
  if(parameter_mat[world, beta_1 == 0]){t1_id <- t1_id + 1}
  seed_i <- 1
  beta_1 <- parameter_mat[world, beta_1]
  beta_2 <- beta_1
  beta_3 <- beta_1
  n_id <- parameter_mat[world, n_id]
  gamma_0 <- parameter_mat[world, gamma_0]
  gamma_1 <- parameter_mat[world, gamma_1]
  if(gamma_1 == -1){gamma_1 <- gamma_0}
  gamma_2 <- 0.5*gamma_1
  gamma_3 <- 0.25*gamma_1
  sigma_j <- parameter_mat[world, sigma_j]
  if(parameter_mat[world, rho] == "0"){
    rho <- rep(0, p_cor) # r2c1, r3c1,r3c2
  }
  if(parameter_mat[world, rho] == "+"){
    rho <- rho_vec[1:p_cor] # r2c1, r3c1,r3c2
  }
  equal_n_sim <- parameter_mat[world, equal_n]
  
  sim1 <- simulate_this_RCB_no_subsampling(
    seed_i = seed_i,
    n_sim = n_sim,
    n = n,
    n_id = n_id,
    n_treat = n_treat,
    beta = c(beta_0, beta_1, beta_2, beta_3)[1:n_treat],
    sigma = sigma_mat[, sigma_j],
    gamma = c(gamma_0, gamma_1, gamma_2, gamma_3)[1:n_treat],
    rho = rho,
    equal_n = equal_n_sim,
    n_with_missing = n_with_missing,
    n_missing = n_missing,
    do_lme = do_lme
  )

  
  b_hat <- sim1$b_mat
  lower <- sim1$lower_mat
  upper <- sim1$upper_mat
  prob <- sim1$p_mat # remove last 4
  error <- sim1$error_mat

  stat_table <- rbind(data.table(stat = "b_hat", b_hat),
                      data.table(stat = "lower", lower),
                      data.table(stat = "upper", upper),
                      data.table(stat = "prob", prob),
                      data.table(stat = "error", error))
  
  big_table <- rbind(big_table,
                     data.table(
                       sim_id = world,
                       t1_id = t1_id,
                       n = n,
                       n_id = n_id,
                       beta_1 = beta_1,
                       gamma_0 = gamma_0,
                       gamma_1 = gamma_1,
                       sigma = sigma_j,
                       rho = parameter_mat[world, rho],
                       equal_n = equal_n_sim,
                       stat_table
                     ))
}

if(save_it == TRUE){
  outpath <- here::here("sim_data", "multi_experiments_4tr_subsample_heterogeneity-lowpower.Rds")
  saveRDS(big_table, outpath)
}

if(read_it == TRUE){
    outpath <- here::here("sim_data", "multi_experiments_3tr_subsample_power.Rds")
  big_table <- readRDS(outpath)

}
```

### Single factor RCB with subsamples

```{r Single factor RCB with subsamples, message=FALSE, warning=FALSE, eval=FALSE}
save_it <- FALSE
fake_data <- data.table(NULL)
do_lme <- FALSE

n_sim <- 1000
n <- 6
n_adaptive <- 1 #-32 # if < -1, then -n_adaptive/n_id
n_id <- 5
n_id_list <- c(5)
n_treat <- 4
N <- n*n_treat*n_id
p_cor <- n_treat*(n_treat-1)/2 # number of correlations in Psi

beta_0 <- 10
beta_1_list <- c(0)
sigma <- 1
gamma_0_list = c(0, 1) # intercept 
gamma_1_list = c(0, 1) # slope
rho_list <- c("0", "+") # correlation between random intercept and slope
#rho_list <- c("+") # correlation between random intercept and slope
rho_vec <- c(.8, .7, .6, .8, .7, .6)
equal_n_list <- c(TRUE) # equal_n_list
n_with_missing <- 1
n_missing <- 1

parameter_mat <- expand.grid(beta_1 = beta_1_list,
                             gamma_0 = gamma_0_list,
                             gamma_1 = gamma_1_list,
                             rho = rho_list,
                             equal_n = equal_n_list,
                             n_id = n_id_list
                             ) %>%
  data.table
n_param <- nrow(parameter_mat)
parameter_mat <- parameter_mat[c(2,2,8),]
parameter_mat[2:3, beta_1 := 0.8]
parameter_mat <- rbind(parameter_mat, parameter_mat)
parameter_mat[4:6, equal_n := FALSE]
parameter_mat <- parameter_mat[4:6,]

big_table <- data.table(NULL)
t1_id <- 0
for(world in 1:nrow(parameter_mat)){
  if(parameter_mat[world, beta_1 == 0]){t1_id <- t1_id + 1}
  seed_i <- 1
  beta_1 <- parameter_mat[world, beta_1]
  beta_2 <- beta_1
  beta_3 <- beta_1
  n_id <- parameter_mat[world, n_id]
  if(n_adaptive < 0){n <- -n_adaptive/n_id}
  gamma_0 <- parameter_mat[world, gamma_0]
  gamma_1 <- parameter_mat[world, gamma_1]
  if(gamma_1 == -1){gamma_1 <- gamma_0}
  gamma_2 <- 0.5*gamma_1
  gamma_3 <- 0.25*gamma_1
  if(parameter_mat[world, rho] == "0"){
    rho <- rep(0, p_cor) # r2c1, r3c1,r3c2
  }
  if(parameter_mat[world, rho] == "+"){
    rho <- rho_vec[1:p_cor] # r2c1, r3c1,r3c2
  }
  equal_n_sim <- parameter_mat[world, equal_n]
  
  # rm or not?
  sim1 <- simulate_this_RCB_subsampling(
    seed_i = seed_i,
    n_sim = n_sim,
    n = n,
    n_id = n_id,
    n_treat = n_treat,
    beta = c(beta_0, beta_1, beta_2, beta_3)[1:n_treat],
    sigma = sigma,
    gamma = c(gamma_0, gamma_1, gamma_2, gamma_3)[1:n_treat],
    rho = rho,
    equal_n = equal_n_sim,
    n_with_missing = n_with_missing,
    n_missing = n_missing,
    do_lme = do_lme
  )

  
  b_hat <- sim1$b_mat
  lower <- sim1$lower_mat
  upper <- sim1$upper_mat
  prob <- sim1$p_mat # remove last 4
  error <- sim1$error_mat

  stat_table <- rbind(data.table(stat = "b_hat", b_hat),
                      data.table(stat = "lower", lower),
                      data.table(stat = "upper", upper),
                      data.table(stat = "prob", prob),
                      data.table(stat = "error", error))
  
  big_table <- rbind(big_table,
                     data.table(
                       sim_id = world,
                       t1_id = t1_id,
                       n = n,
                       n_id = n_id,
                       beta_1 = beta_1,
                       gamma_0 = gamma_0,
                       gamma_1 = gamma_1,
                       gamma_2 = gamma_2,
                       rho = parameter_mat[world, rho],
                       equal_n = equal_n_sim,
                       stat_table
                     ))
}

if(save_it == TRUE){
  outpath <- here::here("sim_data", "multi_experiments_4tr_subsample_exp1.Rds")
  saveRDS(big_table, outpath)
}
read_it == FALSE
if(read_it == TRUE){
    outpath <- here::here("sim_data", "multi_experiments_3tr_subsample_power.Rds")
  big_table <- readRDS(outpath)

}
```

```{r tables}
b_table <- data.table(NULL)
coverage_table <- data.table(NULL)
prob_less_than_table <- data.table(NULL)
error_less_than_table <- data.table(NULL)
error_less_than_critical_table <- data.table(NULL)
error_less_than_penalized_table <- data.table(NULL)

start_col <- which(names(big_table) == "stat") + 1
methods <- names(big_table)[start_col:ncol(big_table)]

error_less_than_critical <- numeric(length(methods))
names(error_less_than_critical) <- methods
error_less_than_penalized <- numeric(length(methods))
names(error_less_than_penalized) <- methods

full_ycols <- c("n",  "n_id", "beta_1", "gamma_0", "gamma_1", "sigma", "rho", "equal_n")
ycols <- c("n",  "n_id", "beta_1", "gamma_0", "gamma_1", "sigma", "rho", "equal_n")

for(i in seq_along(unique(big_table$sim_id))){
  parameter_row <- big_table[stat == "lower" & sim_id == i][1,]
  parameter_vec <- parameter_row[, .SD, .SDcols = ycols]
  lower <- big_table[stat == "lower" & sim_id == i,
                     .SD, .SDcols = methods]
  upper <- big_table[stat == "upper" & sim_id == i,
                     .SD, .SDcols = methods]
  prob <- big_table[stat == "prob" & sim_id == i,
                    .SD, .SDcols = methods]
  error <- big_table[stat == "error" & sim_id == i,
                     .SD, .SDcols = methods]
  error_t1 <- big_table[stat == "error" & sim_id == t1_id,
                     .SD, .SDcols = methods]
  
  beta_1_sim <- parameter_row[1, beta_1]
  coverage_mat <- ifelse(lower < beta_1_sim &
                           upper > beta_1_sim, 1, 0)
  
  exclude_error <- FALSE
  if(exclude_error == TRUE){
    coverage_mat[is.na(error)] <- NA
  }
  
  coverage <- apply(coverage_mat, 2, sum, na.rm=TRUE)/
    apply(coverage_mat, 2, function(x) sum(!is.na(x)))
  
  prob_less_than <- apply(prob, 2, function(x) mean(x < 0.05, na.rm = TRUE))
  
  error_less_than <- apply(error, 2, function(x) mean(x < 0.05, na.rm = TRUE))
  
  crit_p <- apply(error_t1, 2, function(x) mean(x < 0.05, na.rm = TRUE))
  
  for(j in 1:ncol(error)){
    error_less_than_critical[j] <- mean(error[, ..j] < crit_p[j], na.rm = TRUE)
    error_less_than_penalized[j] <- error_less_than[j]/(1 + abs(1 - crit_p[j]/0.05))
  }
  
  coverage_table <- rbind(
    coverage_table,
    data.table(
      parameter_vec,
      t(coverage)
    ))
  
  prob_less_than_table <- rbind(
    prob_less_than_table,
    data.table(
      parameter_vec,
      t(prob_less_than)
    ))
  
  error_less_than_table <- rbind(
    error_less_than_table,
    data.table(
      parameter_vec,
      t(error_less_than)
    ))

  error_less_than_critical_table <- rbind(
    error_less_than_critical_table,
    data.table(
      parameter_vec,
      t(error_less_than_critical)
    ))

  error_less_than_penalized_table <- rbind(
    error_less_than_penalized_table,
    data.table(
      parameter_vec,
      t(error_less_than_penalized)
    ))

}

coverage_table[, sim := .I]
coverage_long <- melt(coverage_table,
                      measure.vars = methods,
                      variable.name = "method",
                      value.name = "coverage")

error_less_than_table %>%
  kable(digits = 3) %>%
  kable_styling()

coverage_table %>%
  kable(digits = 3) %>%
  kable_styling()


# error_less_than_penalized_table %>%
#   kable(digits = 3) %>%
#   kable_styling()
# 
# error_less_than_critical_table %>%
#   kable(digits = 3) %>%
#   kable_styling()
```

```{r b_hat}
start_col <- which(names(big_table) == "stat") + 1
methods <- names(big_table)[start_col:ncol(big_table)]

b_hat_mat <- melt(big_table[stat == "b_hat"],
                       measure.vars = methods,
                       variable.name = "method",
                       value.name = "b_hat")
b_hat_long <- b_hat_mat[stat == "b_hat",
                         .(b_hat = mean(b_hat, na.rm = TRUE)),
                         by = .(sim_id, method)]
b_hat_wide <- dcast(b_hat_long,
                    sim_id ~ method,
                    value.var = "b_hat")
b_hat_wide %>%
  kable(digits = 3) %>%
  kable_styling()
```

Type S
```{r}
start_col <- which(names(big_table) == "stat") + 1
methods <- names(big_table)[start_col:ncol(big_table)]

b_hat_mat <- melt(big_table[stat == "b_hat"],
                       measure.vars = methods,
                       variable.name = "method",
                       value.name = "b_hat")
p_hat_mat <- melt(big_table[stat == "error"],
                       measure.vars = methods,
                       variable.name = "method",
                       value.name = "p_value")
b_hat_mat[, p_value := p_hat_mat[, p_value]]

b_hat_long <- b_hat_mat[stat == "b_hat",
                         .(type_s = mean(b_hat < 0 & p_value < 0.05),
                           na.rm = TRUE),
                         by = .(sim_id, method)]

b_hat_wide <- dcast(b_hat_long,
                    sim_id ~ method,
                    value.var = "type_s")
b_hat_wide %>%
  kable(digits = 3) %>%
  kable_styling()
```

Frequency of no boundary error
```{r}
big_table[stat == "error", .("lmm_slope" = mean(!is.na(lmm_slope)),
              "lmm_intercept" = mean(!is.na(lmm_intercept)),
              "lmm_intercept_ixn" = mean(!is.na(lmm_intercept_ixn))), by = sim_id]
```

Frequency of best lmm model
```{r}
big_table[stat == "error" & !is.na(lmm_safe_aic),
          .("lmm_slope" = sum(lmm_slope == lmm_safe_aic,
                               na.rm = TRUE)/2000,
            "lmm_intercept" = sum(lmm_intercept == lmm_safe_aic,
                               na.rm = TRUE)/2000,
            "lmm_intercept_ixn" = sum(lmm_intercept_ixn == lmm_safe_aic,
                               na.rm = TRUE)/2000), by = sim_id]
```

